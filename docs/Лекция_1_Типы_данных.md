# Лекция 1. Типы данных

*Конспект по материалам курса — готовый к подаче*

---

## Что такое тип данных

Тип данных — это не просто «число» или «буква». По сути это три вещи в одном: **имя типа**, **размер выделяемой памяти** и **способ представления** значения. Компилятор по типу понимает, сколько байт зарезервировать и как их интерпретировать.

---

## Переменные

**Объявление переменной** — это выделение памяти.  
**Описание переменной** — объявление доступа к уже выделенной памяти (например, через `extern`).

Синтаксис:

```
Тип имя1[= начальное значение1], имя2[= начальное значение2];
```

Примеры: `int x = 5;`, `float a, b = 3.14;`

### Именование

- **верблюжьяНотация** (camelCase) или **нижние_подчёркивания**
- **Венгерская нотация** — префикс по типу: `nByte` (int), `pPtr` (указатель), `lpszCmdLine` (long pointer to string, zero-terminated). Часто встречается в старом коде Windows.

---

## Базовые типы данных

| Тип | Пример | Спецификаторы | Способ представления |
|-----|--------|---------------|----------------------|
| **char** | '5' | signed / unsigned, short, long | Число в двоичной системе. Вопрос: есть ли отрицательные числа в 2СС? А дроби? |
| **int** | 5 | — | Прямое двоичное представление целого |
| **float** | 5.0 | — | Знак + порядок + мантисса |
| **double** | 5.0 | — | То же, но точнее |
| **void** | — | — | Память занята; тип переменной определяет, как интерпретировать данные |

### Класс памяти (storage class)

- **auto** — по умолчанию для локальных переменных
- **register** — подсказка компилятору хранить переменную в регистре
- **static** — переменная не уничтожается при выходе из блока `{ }`
- **extern** — переменная объявлена (память выделена) в другом файле, здесь только описание

---

## Константы

Очень важно различать типы в выражениях. **Какой результат дают `2/3` и `2/3.0`?**

- `2/3` — целочисленное деление, результат **0**
- `2/3.0` — вещественное деление, результат **0.666...**

Строки — это уже «надстройка» над типом `char`. Важный вопрос: **чем отличается `'a'` от `"a"`?**

- `'a'` — один символ типа `char`
- `"a"` — строка из двух символов: `'a'` и `'\0'` (конец строки)

---

## Надстройки над базовыми типами

На базе простых типов строятся более сложные:

1. **Массив**
2. **Указатель (ссылка)**
3. **Структура**
4. **Функция**

---

## Указатели

```c
int *a;
int b;
a = &b;   // a хранит адрес b
*a = 5;   // теперь b тоже равна 5
```

**Как писать: `int* a` или `int *a`?** Оба варианта верны. Важно понимать: `*a` — это целое число; `a` — переменная, хранящая адрес.

Начальные значения: у глобальных переменных — 0, у локальных — не определено.

---

## Массивы

```c
Тип имя[размерность];
```

Многомерный массив — массив массивов:

```c
int Matr[5][10];  // 5 массивов по 10 элементов
```

**Особенности:**

- Непрерывная область памяти, доступ по индексу
- Нумерация с **0**
- Имя массива — указатель на его начало
- `A[i]` эквивалентно `*(A+i)`

**Опасность:** в C нет проверки границ. `Array[5]` при размере 5 — обращение к «шестому» элементу (вне массива). Такие обращения синтаксически допустимы и приводят к неопределённому поведению:

```c
int Array[5];
for (int i = 0; i < 1000; i++) Array[i] = i;  // синтаксически верно, но опасно!
```

---

## Структуры

```c
struct Student {
    char name[30];
    float mark;
};  // это объявление типа

struct Student Starosta, Group[30], *S_ptr;  // переменные
```

**Доступ к полям:**

- Через переменную: `.` — `Group[1].name[0]`
- Через указатель: `->` — `S_ptr->name[0]`

Пример: `S_ptr = &Group[1];` — указатель хранит адрес второго студента.

---

## Функции

```c
Тип имя_функции(список параметров) { тело }
```

Объявление можно ставить где угодно, но функция видна только для кода **ниже** неё. Поэтому используют **прототипы** — объявления без тела в начале файла.

### Передача аргументов

| По значению | По ссылке |
|-------------|-----------|
| Передаются копии аргументов | Передаются адреса |
| Изменения внутри функции не затрагивают оригинал | Изменения параметров меняют переменные в месте вызова |

### Указатель на функцию

```c
Тип (*имя)(список параметров);
```

Так можно передавать функции как аргументы и вызывать их косвенно.

---

## Представление информации в памяти

### Целые положительные числа

Используется двоичная система (прямой код). Диапазон ограничен числом разрядов.

Пример: 7 разрядов → от 0 (0000000₂) до 127 (1111111₂). Всего 128 значений.

### Целые отрицательные числа

Если просто поставить 1 в старшем разряде как знак «минус», получаем два нуля:
- «Положительный» ноль: 0000000
- «Отрицательный» ноль: 1000000

Поэтому используют **дополнительный код**. С его помощью ноль единственный, а отрицательные числа корректно складываются и вычитаются.

Пример проверки (5 разрядов): 32 − 6 = 24₁₀ = 11000₂.

### Вещественные числа (float, double)

Любое число: **N = M · qᵖ**, где M — мантисса (0,1 ≤ |M| < 1), p — порядок.

Один и тот же пример по-разному:  
46,532₁₀ = 4,6532·10¹ = 0,46532·10²

В компьютере q = 2. Число переводят в 2СС, затем в **нормализованный вид** (целая часть = 1). Целую часть отбрасывают и хранят только мантиссу и порядок.

Пример: 46,532₁₀ = 101110,10001₂ = 1,0111010001·2⁵  
Мантисса: 0111010001, порядок: 101₂ = 5₁₀

Порядок хранят **со смещением** (например, +127), чтобы он был неотрицательным. Смещённый порядок: 5 + 127 = 132 = 10000100₂.

**Float (32 бита):** мантисса 23 бита, порядок 8 бит. Диапазон примерно от −3,4·10³⁸ до 3,4·10³⁸.

### Символы

**ASCII** — 1 байт на символ, 256 кодов. Первые 128 символов — стандартная таблица.

**Unicode** (в Windows часто 2 байта) — 2¹⁶ символов. Стандарт для представления символов всех письменностей мира.

---

*Конец лекции 1*
